import Joi from "joi";
import { OBJECT_ID_RULE, OBJECT_ID_RULE_MESSAGE } from "../utils/validators";
import { GET_DB } from "../config/mongodb";
import { ObjectId } from "mongodb";
import { BOARD_TYPES } from "../utils/constants";
import { columnModel } from "./columnModel";
import { cardModel } from "./cardModel";
import { pagingSkipValue } from "../utils/algorithms";
import { userModel } from "./userModel";

const BOARD_COLLECTION_NAME = "boards";
const BOARD_COLLECTION_SCHEMA = Joi.object({
    title: Joi.string().required().min(3).max(50).trim().strict(),
    slug: Joi.string().required().min(3).trim().strict(),
    description: Joi.string().required().min(3).max(256).trim().strict(),
    boardCover: Joi.string().default(null),
    type: Joi.string()
        .valid(...Object.values(BOARD_TYPES))
        .required(),

    columnOrderIds: Joi.array()
        .items(
            Joi.string().pattern(OBJECT_ID_RULE).message(OBJECT_ID_RULE_MESSAGE)
        )
        .default([]),
    ownerIds: Joi.array()
        .items(
            Joi.string().pattern(OBJECT_ID_RULE).message(OBJECT_ID_RULE_MESSAGE)
        )
        .default([]),
    memberIds: Joi.array()
        .items(
            Joi.string().pattern(OBJECT_ID_RULE).message(OBJECT_ID_RULE_MESSAGE)
        )
        .default([]),
    createdAt: Joi.date().timestamp("javascript").default(Date.now),
    updatedAt: Joi.date().timestamp("javascript").default(null),
    _destroy: Joi.boolean().default(false),
});

const INVALID_UPDATE_FIELDS = ["_id", "createdAt"];

const validateBeforeCreate = async (data) => {
    return await BOARD_COLLECTION_SCHEMA.validateAsync(data, {
        abortEarly: false,
    });
};

const createNew = async (userId, data) => {
    try {
        const validData = await validateBeforeCreate(data);

        const newBoardToAdd = {
            ...validData,
            ownerIds: [new ObjectId(userId)],
        };
        const createdBoard = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .insertOne(newBoardToAdd);
        return createdBoard;
    } catch (error) {
        throw new Error(error);
    }
};

const findOneById = async (boardId) => {
    try {
        const result = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .findOne({
                _id: new ObjectId(boardId),
            });
        return result;
    } catch (error) {
        throw new Error(error);
    }
};

const deleteOneById = async (boardId) => {
    try {
        const result = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .deleteOne({
                _id: new ObjectId(boardId),
            });
        // console.log("üöÄ ~ deleteOneById ~ result:", result);

        return result;
    } catch (error) {
        throw new Error(error);
    }
};
// Query t·ªïng h·ª£p (aggregate) ƒë·ªÉ l·∫•y to√†n b·ªô Columns v√† Cards thu·ªôc v·ªÅ Board
const getDetails = async (userId, boardId) => {
    try {
        const queryConditions = [
            { _id: new ObjectId(boardId) },
            { _destroy: false },
            {
                $or: [
                    { ownerIds: { $all: [new ObjectId(userId)] } },
                    { memberIds: { $all: [new ObjectId(userId)] } },
                ],
            },
        ];

        const result = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .aggregate([
                { $match: { $and: queryConditions } },
                {
                    $lookup: {
                        from: columnModel.COLUMN_COLLECTION_NAME,
                        localField: "_id", //ƒë√¢y l√† id c·ªßa board
                        foreignField: "boardId", //ƒë√¢y l√† id c·ªßa board ·ªü column( column thu·ªôc board n√†o)
                        as: "columns", //as ƒë·ªÉ ƒë·ªãnh nghƒ©a t√™n thu·ªôc t√≠nh tr√™n db
                    },
                },
                {
                    $lookup: {
                        from: cardModel.CARD_COLLECTION_NAME,
                        localField: "_id", //ƒë√¢y l√† id c·ªßa board
                        foreignField: "boardId", //ƒë√¢y l√† id c·ªßa board ·ªü card( card thu·ªôc board n√†o)
                        as: "cards",
                    },
                },
                {
                    $lookup: {
                        from: userModel.USER_COLLECTION_NAME,
                        localField: "ownerIds", //ƒë√¢y l√† owerIds c·ªßa board
                        foreignField: "_id", //ƒë√¢y l√† id user owr usermodel
                        as: "owners", //tr·∫£ v·ªÅ m·∫£ng c√≥ t√™n owners
                        //pipeline trong lookup l√† ƒë·ªÉ x·ª≠ l√Ω m·ªôt ho·∫∑c nhi·ªÅu lu·ªìng c·∫ßn thi·∫øt
                        //$project ƒë·ªÉ ch·ªâ ƒë·ªãnh v√†i field kh√¥ng mu·ªën l·∫•y v·ªÅ b·∫±ng c√°ch g√°n n√≥ gi√° tr·ªã 0
                        pipeline: [
                            { $project: { password: 0, verifyToken: 0 } },
                        ],
                    },
                },
                {
                    $lookup: {
                        from: userModel.USER_COLLECTION_NAME,
                        localField: "memberIds",
                        foreignField: "_id",
                        as: "members",
                        //pipeline trong lookup l√† ƒë·ªÉ x·ª≠ l√Ω m·ªôt ho·∫∑c nhi·ªÅu lu·ªìng c·∫ßn thi·∫øt
                        //$project ƒë·ªÉ ch·ªâ ƒë·ªãnh v√†i field kh√¥ng mu·ªën l·∫•y v·ªÅ b·∫±ng c√°ch g√°n n√≥ gi√° tr·ªã 0
                        pipeline: [
                            { $project: { password: 0, verifyToken: 0 } },
                        ],
                    },
                },
            ])
            .toArray();
        // console.log(result);
        return result[0] || null;
    } catch (error) {
        throw new Error(error);
    }
};
const pushColumnOrderIds = async (column) => {
    try {
        const result = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .findOneAndUpdate(
                { _id: new ObjectId(column.boardId) },
                { $push: { columnOrderIds: new ObjectId(column._id) } },
                { returnDocument: "after" }
            );
        return result;
    } catch (error) {
        throw new Error(error);
    }
};

const pullColumnOrderIds = async (column) => {
    try {
        const result = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .findOneAndUpdate(
                { _id: new ObjectId(column.boardId) },
                { $pull: { columnOrderIds: new ObjectId(column._id) } },
                { returnDocument: "after" }
            );
        return result;
    } catch (error) {
        throw new Error(error);
    }
};

const update = async (boardId, updateData) => {
    try {
        Object.keys(updateData).forEach((filedName) => {
            if (INVALID_UPDATE_FIELDS.includes(filedName)) {
                delete updateData[filedName];
            }
        });

        if (updateData.columnOrderIds) {
            updateData.columnOrderIds = updateData.columnOrderIds.map(
                (_id) => new ObjectId(_id)
            );
        }

        // Convert boardId to ObjectId
        const objectId = new ObjectId(boardId);
        
        const result = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .findOneAndUpdate(
                { _id: objectId },
                { $set: updateData },
                { returnDocument: "after" }
            );
        return result;
    } catch (error) {
        throw new Error(error);
    }
};

const getBoards = async (userId, page, itemsPerPage, queryFilters) => {
    try {
        const queryConditions = [
            //ƒêK 1: board ch∆∞a b·ªã x√≥a
            { _destroy: false },
            //ƒêk 2: userId ƒëang th·ª±c hi·ªán request ph·∫£i thu·ªôc m·ªôt trong 2 m·∫£ng ownerIds ho·∫∑c memberIds, s·ª≠ d·ª•ng to√°n t·ª´ $all v·ªßa mongodb
            {
                $or: [
                    { ownerIds: { $all: [new ObjectId(userId)] } },
                    { memberIds: { $all: [new ObjectId(userId)] } },
                ],
            },
        ];

        //X·ª≠ l√Ω query filter cho t·ª´ng tr∆∞·ªùng h·ª£p search board: theo title,...
        if (queryFilters) {
            Object.keys(queryFilters).forEach((key) => {
                //Ph√¢n bi·ªát ch·ªØ hoa th∆∞·ªùng
                // queryConditions.push({
                //     [key]: { $regex: queryFilters[key] },
                // });
                //Kh√¥ng ph√¢n bi·ªát ch·ªØa hoa th∆∞·ªùng
                queryConditions.push({
                    [key]: { $regex: new RegExp(queryFilters[key], "i") },
                });
            });
        }

        const query = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .aggregate(
                [
                    { $match: { $and: queryConditions } },
                    //sort title c·ªßa board theo A-Z
                    { $sort: { title: 1 } },
                    //$facet: x·ª≠ l√Ω nhi·ªÅu lu·ªìng trong 1 query
                    {
                        $facet: {
                            //Lu·ªìng 1: query boards
                            queryBoards: [
                                //B·ªè qua s·ªë l∆∞·ª£ng b·∫£n ghi c·ªßa nh·ªØng page tr∆∞·ªõc ƒë√≥
                                { $skip: pagingSkipValue(page, itemsPerPage) },
                                //Gioi h·∫°n s·ªë l∆∞·ª£ng b·∫£n ghi tr√™n 1 trang l√† 12
                                { $limit: itemsPerPage },
                            ],
                            //Lu·ªìng 2: query ƒë·∫øn t·ªïng t·∫•t c·∫£ s·ªë l∆∞·ª£ng b·∫£n ghi boards trong DB v√† tr·∫£ v·ªÅ v√†o bi·∫øn countedAllBoards
                            queryTotalBoards: [{ $count: "countedAllBoards" }],
                        },
                    },
                ],
                //Khai b√°o th√™m thu·ªôc t√≠nh collation locale 'en' ƒë·ªÉ fix ch·ªØ B hoa v√† s·∫Øp x·∫øp tr∆∞·ªõc a. b·∫£ng m√£ ASII
                { collation: { locale: "en" } }
            )
            .toArray();
        // console.log(" query", query);

        const res = query[0];
        return {
            boards: res.queryBoards || [],
            totalBoards: res.queryTotalBoards[0]?.countedAllBoards || 0,
        };
    } catch (error) {
        throw new Error(error);
    }
};

const pushMemberIds = async (boardId, userId) => {
    try {
        const result = await GET_DB()
            .collection(BOARD_COLLECTION_NAME)
            .findOneAndUpdate(
                { _id: new ObjectId(boardId) },
                { $push: { memberIds: new ObjectId(userId) } },
                { returnDocument: "after" }
            );
        return result;
    } catch (error) {
        throw new Error(error);
    }
};
export const boardModel = {
    BOARD_COLLECTION_NAME,
    BOARD_COLLECTION_SCHEMA,
    createNew,
    findOneById,
    getDetails,
    pushColumnOrderIds,
    update,
    pullColumnOrderIds,
    getBoards,
    pushMemberIds,
    deleteOneById,
};
